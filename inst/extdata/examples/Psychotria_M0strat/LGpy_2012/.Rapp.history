tr
Run an ML search#
########################################################
#
bears_output1 = bears_2param_standard_fast_symOnly(trfn=trfn, geogfn=geogfn)#
bears_output1#
bears_output1$optim_result#
#
#bears_output2 = bears_2param_standard_fast_symOnly_simp(trfn=trfn, geogfn=geogfn)#
#bears_output2#
#
bears_output1$optim_result#
bears_output2$optim_result#
bears_output = bears_2param_standard_fast(trfn=trfn, geogfn=geogfn)#
bears_output#
#
bears_output3 = bears_2param_DIVA_fast(trfn=trfn, geogfn=geogfn)#
bears_output3#
# Extract key parameters and LnL values#
fn_name = "bears_2param_standard_fast"#
tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
results_row = cbind(fn_name, t(tmp_params), tmp_LnL)#
results_row
Loading the packages#
########################################################
# After installing these packages, library() them#
library(ape)		# R phylogenetics package#
library(rexpokit)	# Matrix exponentiation package (by Matzke) using the FORTRAN library EXPOKIT#
					# (by Robert Sidje) to do rapid matrix exponentiation; may require that you#
					# have the FORTRAN compiler, gfortran, installed.#
library(cladoRcpp)	# Package for rapid calculation of cladogenesis models (by Matzke) in C++ and Rcpp. #
library(BioGeoBEARS)# Package using rexpokit & cladoRcpp to do model testing and ancestral range estimation#
					# for historical biogeography (by Matzke)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_classes_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_univ_model_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_readwrite_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_LaplacesDemon_v1.R', chdir = TRUE)
Set your:#
# - working directory (wd)#
# - your Newick phylogeny file#
# - your geography data file#
########################################################
# working directory is currently default; you should change it here#
wd = getwd()	# get working directory, store in wd#
setwd(wd)		# set working directory#
#
# Here, I am using the practice files inside the R package;#
# you can use your own#
# Normally#
extdata_dir = system.file("extdata", package="BioGeoBEARS")#
# tmp hard code NICK FIX: #
# extdata_dir = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/"#
#
# Set the filenames (Hawaiian Psychotria from Ree & Smith 2008)#
trfn = paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep="")#
tr = read.tree(file=trfn)#
#
geogfn = paste(addslash(extdata_dir), "Psychotria_geog.data", sep="")#
#
# Look at the tree and ranges, for kicks#
getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tr
Run a bunch ML searches on different models#
#  - No constraints on maxareas#
#  - No time-stratification#
########################################################
# Set the filename & save directory#
fn_prefix = "Hawaiian_Psychotria_M0_unconstrained_7bearsModels"#
# savedir = addslash(wd)			# If you are making new files, use this.#
savedir = addslash(extdata_dir)				# For Nick's machine
function_names = c("bears_2param_standard_fast_symOnly",#
"bears_2param_standard_fast",#
"bears_2param_DIVA_fast", #
"bears_3param_standard_fast")#
#
nparams = c(2,2,2,3)
Run the models from scratch if TRUE#
runthis = TRUE#
if (runthis)#
	{#
	#########################################################
	# Run the inference on all models#
	#########################################################
	results_list = NULL#
	for (i in 1:length(function_names))#
		{#
		# Write the command#
		cmdstr = paste("bears_output = ", function_names[i], "(trfn=trfn, geogfn=geogfn)", sep="")#
		# Execute the command#
		eval(parse(text=cmdstr))#
		# Store the results, if desired#
		results_list[[i]] = bears_output#
		}#
	results_list_save = results_list#
	# Save an .Rdata file to savedir#
	save(results_list_save, file=paste(savedir, fn_prefix, ".Rdata", sep=""))#
	# Done saving#
	} else {#
	#########################################################
	# Load the results from previously-saved results#
	#########################################################
	# "load" returns the text name of the object#
	cmdstr = paste("object_name = load(file='", savedir, fn_prefix, ".Rdata')", sep="")#
	eval(parse(text=cmdstr))#
	# Copy the loaded object to the desired variable#
	cmdstr = paste("results_list_save = ", object_name, sep="")#
	eval(parse(text=cmdstr))#
	# Done loading#
	}
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)
Run a bunch ML searches on different models#
#  - No constraints on maxareas#
#  - No time-stratification#
########################################################
# Set the filename & save directory#
fn_prefix = "Hawaiian_Psychotria_M0_unconstrained_7bearsModels"#
# savedir = addslash(wd)			# If you are making new files, use this.#
savedir = addslash(extdata_dir)				# For Nick's machine#
#
# What sets of parameters do we want to optimize over?#
# See help files for the description of each model#
# function_names = c("bears_2param_standard_fast_symOnly",#
# "bears_2param_standard_fast",#
# "bears_2param_DIVA_fast", #
# "bears_3param_standard_fast",#
# "bears_4param_standard_fast",#
# "bears_5param_standard_fast",#
# "bears_5param_standard_fast_v",#
# "bears_6param_standard_fast_ys_v")#
# #
# nparams = c(2,2,2,3,4,5,5,6)#
#
function_names = c("bears_2param_standard_fast_symOnly",#
"bears_2param_standard_fast",#
"bears_2param_DIVA_fast", #
"bears_3param_standard_fast")#
#
nparams = c(2,2,2,3)#
# Run the models from scratch if TRUE#
runthis = TRUE#
if (runthis)#
	{#
	#########################################################
	# Run the inference on all models#
	#########################################################
	results_list = NULL#
	for (i in 1:length(function_names))#
		{#
		# Write the command#
		cmdstr = paste("bears_output = ", function_names[i], "(trfn=trfn, geogfn=geogfn)", sep="")#
		# Execute the command#
		eval(parse(text=cmdstr))#
		# Store the results, if desired#
		results_list[[i]] = bears_output#
		}#
	results_list_save = results_list#
	# Save an .Rdata file to savedir#
	save(results_list_save, file=paste(savedir, fn_prefix, ".Rdata", sep=""))#
	# Done saving#
	} else {#
	#########################################################
	# Load the results from previously-saved results#
	#########################################################
	# "load" returns the text name of the object#
	cmdstr = paste("object_name = load(file='", savedir, fn_prefix, ".Rdata')", sep="")#
	eval(parse(text=cmdstr))#
	# Copy the loaded object to the desired variable#
	cmdstr = paste("results_list_save = ", object_name, sep="")#
	eval(parse(text=cmdstr))#
	# Done loading#
	}#
#
# Gather the results into a summary table#
results_summary_table = NULL#
for (i in 1:length(function_names))#
	{#
	# Extract results #i#
	bears_output = results_list_save[[i]]#
	# Extract key parameters and LnL values#
	fn_name = function_names[i]#
	tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
	tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
	results_row = cbind(fn_name, nparams[i], trfn, geogfn, t(tmp_params), tmp_LnL)#
	results_row#
	# add row to table#
	results_summary_table = rbind(results_summary_table, results_row)#
	}#
results_summary_table = dfnums_to_numeric(unlist_df3(results_summary_table))#
results_summary_table#
names(results_summary_table)[(names(results_summary_table) == "nparams[i]")] = "nparams"
results_summary_table
results_row
results_list_save
length(results_list_save)
results_list_save[[3]]
A basic run of biogeography models in #
# Nick Matzke's BioGeoBEARS R package#
########################################################
#
########################################################
# NOTES:#
# #
# 1. THIS IS STILL IN DEVELOPMENT/EXPERIMENTAL. YOU HAVE#
# BEEN WARNED.#
##
# 2. IT IS GOOD TO UNDERSTAND ROUGHLY WHAT IS GOING ON.  #
#    THE MOST COMMON ISSUE IS WITH DIRECTORIES/FILES,#
#    WHICH MUST BE CORRECT, BUT I CAN'T ALWAYS PREDICT#
#    WHAT WILL WORK ON E.G. WINDOWS VS. MACS etc.#
##
#    My notation, so you can figure this out:#
#    wd = working directory#
#    fn = filename#
#    extdata_dir = extension data directory#
##
# 3. After reading #2 above, please send comments/#
#    corrections etc. to me, Nick Matzke, at#
#    matzke@berkeley.edu#
# #
########################################################
########################################################
# Installation#
########################################################
# Install these packages#
# install.packages("devtools")#
# install.packages("ape")#
# install.packages("rexpokit")#
# #
# # This is probably good enough on most machines#
# install.packages("cladoRcpp")#
# #
# # # But this works on Nick's machine, which likes --no-multiarch tags during install (which means#
# # # install for just 64-bit operation, not 32-bit operation)#
# # detach("package:cladoRcpp")#
# # library(cladoRcpp)#
# # (pkgdir = system.file(package="cladoRcpp"))#
# # pkgdir = gsub("cladoRcpp", "", pkgdir)	# remove "cladoRcpp" from pkdir#
# # remove.packages("cladoRcpp")			# remove from default location#
# # remove.packages("cladoRcpp", pkgdir)	# remove from other location#
# # (pkgdir = system.file(package="cladoRcpp"))#
# # install.packages("cladoRcpp", lib='/Library/Frameworks/R.framework/Resources/library/',contriburl=contrib.url(getOption("repos")),'source',dependencies=FALSE, INSTALL_opts=c("--no-multiarch"))#
# #
# #
# # Now, try installing the draft version of BioGeoBEARS from the github repository:#
# # https://github.com/nmatzke/BioGeoBEARS#
# # Doing this in R requires the devtools package.#
# library(devtools)	# For install_github#
# #
# # Remove the old version of BioGeoBEARS#
# remove.packages("BioGeoBEARS")#
# detach(package:BioGeoBEARS, unload='TRUE')#
# #
# # Then install the newest version#
# install_github(repo="BioGeoBEARS", username="nmatzke", ref="master", args=c("--no-multiarch"))#
# #
########################################################
# Loading the packages#
########################################################
# After installing these packages, library() them#
library(ape)		# R phylogenetics package#
library(rexpokit)	# Matrix exponentiation package (by Matzke) using the FORTRAN library EXPOKIT#
					# (by Robert Sidje) to do rapid matrix exponentiation; may require that you#
					# have the FORTRAN compiler, gfortran, installed.#
library(cladoRcpp)	# Package for rapid calculation of cladogenesis models (by Matzke) in C++ and Rcpp. #
library(BioGeoBEARS)# Package using rexpokit & cladoRcpp to do model testing and ancestral range estimation#
					# for historical biogeography (by Matzke)#
#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)					#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_classes_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_univ_model_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_readwrite_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_LaplacesDemon_v1.R', chdir = TRUE)#
########################################################
# Set your:#
# - working directory (wd)#
# - your Newick phylogeny file#
# - your geography data file#
########################################################
# working directory is currently default; you should change it here#
wd = getwd()	# get working directory, store in wd#
setwd(wd)		# set working directory#
#
# Here, I am using the practice files inside the R package;#
# you can use your own#
# Normally#
extdata_dir = system.file("extdata", package="BioGeoBEARS")#
# tmp hard code NICK FIX: #
# extdata_dir = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/"#
#
# Set the filenames (Hawaiian Psychotria from Ree & Smith 2008)#
trfn = paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep="")#
tr = read.tree(file=trfn)#
#
geogfn = paste(addslash(extdata_dir), "Psychotria_geog.data", sep="")#
#
# Look at the tree and ranges, for kicks#
getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tr#
########################################################
# Run an ML search#
########################################################
#
bears_output1 = bears_2param_standard_fast_symOnly(trfn=trfn, geogfn=geogfn)#
bears_output1#
bears_output1$optim_result#
#
#bears_output2 = bears_2param_standard_fast_symOnly_simp(trfn=trfn, geogfn=geogfn)#
#bears_output2#
#
bears_output1$optim_result#
bears_output2$optim_result#
bears_output = bears_2param_standard_fast(trfn=trfn, geogfn=geogfn)#
bears_output#
#
bears_output3 = bears_2param_DIVA_fast(trfn=trfn, geogfn=geogfn)#
bears_output3#
# Extract key parameters and LnL values#
fn_name = "bears_2param_standard_fast"#
tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
results_row = cbind(fn_name, t(tmp_params), tmp_LnL)#
results_row#
########################################################
# Run a bunch ML searches on different models#
#  - No constraints on maxareas#
#  - No time-stratification#
########################################################
# Set the filename & save directory#
fn_prefix = "Hawaiian_Psychotria_M0_unconstrained_7bearsModels"#
# savedir = addslash(wd)			# If you are making new files, use this.#
savedir = addslash(extdata_dir)				# For Nick's machine#
#
# What sets of parameters do we want to optimize over?#
# See help files for the description of each model#
# function_names = c("bears_2param_standard_fast_symOnly",#
# "bears_2param_standard_fast",#
# "bears_2param_DIVA_fast", #
# "bears_3param_standard_fast",#
# "bears_4param_standard_fast",#
# "bears_5param_standard_fast",#
# "bears_5param_standard_fast_v",#
# "bears_6param_standard_fast_ys_v")#
# #
# nparams = c(2,2,2,3,4,5,5,6)#
#
function_names = c("bears_2param_standard_fast_symOnly",#
"bears_2param_standard_fast",#
"bears_2param_DIVA_fast", #
"bears_3param_standard_fast")#
#
nparams = c(2,2,2,3)#
# Run the models from scratch if TRUE#
runthis = TRUE#
if (runthis)#
	{#
	#########################################################
	# Run the inference on all models#
	#########################################################
	results_list = NULL#
	for (i in 1:length(function_names))#
		{#
		# Write the command#
		cmdstr = paste("bears_output = ", function_names[i], "(trfn=trfn, geogfn=geogfn)", sep="")#
		# Execute the command#
		eval(parse(text=cmdstr))#
		# Store the results, if desired#
		results_list[[i]] = bears_output#
		}#
	results_list_save = results_list#
	# Save an .Rdata file to savedir#
	save(results_list_save, file=paste(savedir, fn_prefix, ".Rdata", sep=""))#
	# Done saving#
	} else {#
	#########################################################
	# Load the results from previously-saved results#
	#########################################################
	# "load" returns the text name of the object#
	cmdstr = paste("object_name = load(file='", savedir, fn_prefix, ".Rdata')", sep="")#
	eval(parse(text=cmdstr))#
	# Copy the loaded object to the desired variable#
	cmdstr = paste("results_list_save = ", object_name, sep="")#
	eval(parse(text=cmdstr))#
	# Done loading#
	}
Gather the results into a summary table#
results_summary_table = NULL#
for (i in 1:length(function_names))#
	{#
	# Extract results #i#
	bears_output = results_list_save[[i]]#
	# Extract key parameters and LnL values#
	fn_name = function_names[i]#
	tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
	tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
	results_row = cbind(fn_name, nparams[i], trfn, geogfn, t(tmp_params), tmp_LnL)#
	results_row#
	# add row to table#
	results_summary_table = rbind(results_summary_table, results_row)#
	}
i
bears_output = results_list_save[[i]]#
	# Extract key parameters and LnL values#
	fn_name = function_names[i]#
	tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
	tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
	results_row = cbind(fn_name, nparams[i], trfn, geogfn, t(tmp_params), tmp_LnL)#
	results_row
results_summary_table = rbind(results_summary_table, results_row)
results_summary_table
results_row
dim(results_row)
dim(results_summary_table)
tmp_params
tmp_LnL
Loading the packages#
########################################################
# After installing these packages, library() them#
library(ape)		# R phylogenetics package#
library(rexpokit)	# Matrix exponentiation package (by Matzke) using the FORTRAN library EXPOKIT#
					# (by Robert Sidje) to do rapid matrix exponentiation; may require that you#
					# have the FORTRAN compiler, gfortran, installed.#
library(cladoRcpp)	# Package for rapid calculation of cladogenesis models (by Matzke) in C++ and Rcpp. #
library(BioGeoBEARS)# Package using rexpokit & cladoRcpp to do model testing and ancestral range estimation#
					# for historical biogeography (by Matzke)#
#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)					#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_classes_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_univ_model_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_readwrite_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_LaplacesDemon_v1.R', chdir = TRUE)
Gather the results into a summary table#
results_summary_table = NULL#
for (i in 1:length(function_names))#
	{#
	# Extract results #i#
	bears_output = results_list_save[[i]]#
	# Extract key parameters and LnL values#
	fn_name = function_names[i]#
	tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
	tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
	results_row = cbind(fn_name, nparams[i], trfn, geogfn, t(tmp_params), tmp_LnL)#
	results_row#
	# add row to table#
	results_summary_table = rbind(results_summary_table, results_row)#
	}#
results_summary_table = dfnums_to_numeric(unlist_df3(results_summary_table))#
results_summary_table#
names(results_summary_table)[(names(results_summary_table) == "nparams[i]")] = "nparams"
i
tmp_params
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_simulate_v1.R', chdir = TRUE)
Gather the results into a summary table#
results_summary_table = NULL#
for (i in 1:length(function_names))#
	{#
	# Extract results #i#
	bears_output = results_list_save[[i]]#
	# Extract key parameters and LnL values#
	fn_name = function_names[i]#
	tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
	tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
	results_row = cbind(fn_name, nparams[i], trfn, geogfn, t(tmp_params), tmp_LnL)#
	results_row#
	# add row to table#
	results_summary_table = rbind(results_summary_table, results_row)#
	}#
results_summary_table = dfnums_to_numeric(unlist_df3(results_summary_table))#
results_summary_table#
names(results_summary_table)[(names(results_summary_table) == "nparams[i]")] = "nparams"
results_summary_table = dfnums_to_numeric(unlist_df3(results_summary_table))#
results_summary_table#
names(results_summary_table)[(names(results_summary_table) == "nparams[i]")] = "nparams"
Likelihood Ratio Tests#
lrtest_table = lrttest_on_summary_table(restable=results_summary_table, row_to_use_as_null=2, rows_to_exclude=c(1), returnwhat="all", add_to_table=FALSE)#
lrtest_table#
# AIC, AICc#
AIC_col = calc_AIC_column(LnL_vals=results_summary_table$LnL, nparam_vals=results_summary_table$nparams)#
results_summary_table2 = cbind(results_summary_table, AIC_col)#
AICc_col = calc_AICc_column(LnL_vals=results_summary_table2$LnL, nparam_vals=results_summary_table2$nparams, samplesize=length(tr$tip.label))#
results_summary_table3 = cbind(results_summary_table2, AICc_col)#
results_summary_table3#
#
# AIC weight, AICc weight across all models (each column sums to 1)#
results_summary_table4 = AkaikeWeights_on_summary_table(results_summary_table3, colname_to_use="AIC", add_to_table=TRUE)#
results_summary_table5 = AkaikeWeights_on_summary_table(results_summary_table4, colname_to_use="AICc", add_to_table=TRUE)#
results_summary_table5#
#
# Test calculations of Akaike weights#
deltaAICs = get_deltaAIC(AICvals=results_summary_table5$AIC)#
rel_likes_AIC = rel_likes_from_deltaAICs(deltaAICs=deltaAICs)#
Akaike_weights = get_Akaike_weights_from_rel_likes(rel_likes_AIC)#
cbind(deltaAICs, rel_likes_AIC, Akaike_weights)#
# AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table2, colname_to_use="AIC", ref_model="best", add_to_table=FALSE)#
AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table5, colname_to_use="AIC", ref_model=2, add_to_table=FALSE)#
AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table5, colname_to_use="AICc", ref_model=2, add_to_table=FALSE)#
#
results_summary_table6 = AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table5, colname_to_use="AIC", ref_model=2, add_to_table=TRUE)#
# AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table2, colname_to_use="AICc", ref_model="best", add_to_table=FALSE)#
results_summary_table7 = AkaikeWeights_and_Ratios_pairwise_on_summary_table_compared_to_ref(results_summary_table6, colname_to_use="AICc", ref_model=2, add_to_table=TRUE)#
results_summary_table7#
########################################################
# Format the output table nicely!#
########################################################
modelnames = c("BayArea (sym-only)", "DEC (LAGRANGE)", "DEC (DIVA)", "DEC+founder", "DECf+v", "DECf+v+mxa", "DECf+v+mxv", "DECf+v+mxa+mxv")#
results_summary_table8 = results_summary_table7#
results_summary_table8$fn_name = modelnames#
#
names_to_keep = c("fn_name", "nparams", "d", "e", "j", "v", "ys", "maxent01", "maxent01v", "LnL", "AIC", "AIC_wt_vBest", "AIC_Akaike_weight_ratio_row_to_ref")#
final_names   = c("model", "np", "d", "e", "j", "v", "ys", "mxa", "mxv", "LnL", "AIC", "Akaike", "prRatio")#
#
results_wAIC = results_summary_table8[,names_to_keep]#
names(results_wAIC) = final_names#
AIC_table_to_print = conditional_format_table(input_table=results_wAIC)#
AIC_table_to_print#
#
names_to_keep = c("fn_name", "nparams", "d", "e", "j", "v", "ys", "maxent01", "maxent01v", "LnL", "AICc", "AICc_wt_vBest", "AICc_Akaike_weight_ratio_row_to_ref")#
final_names   = c("model", "np", "d", "e", "j", "v", "ys", "mxa", "mxv", "LnL", "AICc", "Akaike", "prRatio")#
#
results_wAICc = results_summary_table8[,names_to_keep]#
names(results_wAICc) = final_names#
AICc_table_to_print = conditional_format_table(input_table=results_wAICc)#
AICc_table_to_print#
# Put table into PDF#
# This requires that you have command-line LaTeX install; texlive#
# Change to TRUE to try this#
make_PDF_table = FALSE#
if (make_PDF_table == TRUE)#
	{#
	#pdftable(AIC_table_to_print, size=NULL)#
	pdftable(AIC_table_to_print, size="\\small")#
	#pdftable(AIC_table_to_print, size="\\tiny")#
	}#
########################################################
# Make plots#
########################################################
#
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
########################################################
########################################################
# Plot the various ancestral state estimates#
########################################################
########################################################
piecols = c("black", #
rgb(blue=100, green=0, red=0, maxColorValue=100), #
rgb(blue=100, green=100, red=0, maxColorValue=100), #
rgb(blue=0, green=100, red=100, maxColorValue=100), #
rgb(blue=0, green=0, red=100, maxColorValue=100), #
#
rgb(blue=100, green=50, red=0, maxColorValue=100), #
rgb(blue=75, green=50, red=50, maxColorValue=100), #
rgb(blue=75, green=0, red=50, maxColorValue=100), #
#
rgb(blue=0, green=100, red=50, maxColorValue=100), #
rgb(blue=0, green=50, red=50, maxColorValue=100), #
#
rgb(blue=0, green=50, red=100, maxColorValue=100), #
rgb(blue=50, green=25, red=25, maxColorValue=100), #
rgb(blue=50, green=50, red=25, maxColorValue=100), #
rgb(blue=25, green=25, red=50, maxColorValue=100), #
#
rgb(blue=25, green=50, red=50, maxColorValue=100), #
#
rgb(blue=100, green=100, red=100, maxColorValue=100))#
doPDFs = TRUE#
pdffn = "compare_anc_range_reconstructions_v01.pdf"#
if (doPDFs) #
	{#
	pdf(pdffn, height=11, width=8)#
	}#
par(mfrow=c(2,1))#
############################################################
# 2-parameter model (BayArea-like; #
# see Landis, Matzke, Moore, Huelsenbeck, SysBio, submitted#
############################################################
results_object = results_list_save[[1]]#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on downpass cond. likes. at branch tops with\n'BayArea'-like 2-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = results_list_save[[2]]#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on downpass cond. likes. at branch tops with\nLAGRANGE 2-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
##############################################################
# 3-parameter model (LAGRANGE DEC + founder-event speciation)#
# See Matzke 2013 (poster, in press)#
##############################################################
results_object = results_list_save[[3]]#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips, adj=1.1)# pos=2, offset=1)#
title("Best states based on downpass cond. likes. at branch tops with\nBioGeoBEARS 3-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
############################################################
# 2-parameter model (BayArea-like; #
# see Landis, Matzke, Moore, Huelsenbeck, SysBio, submitted#
############################################################
results_object = results_list_save[[1]]#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith 'BayArea'-like 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = results_list_save[[2]]#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
############################################################
# 2-parameter model (as in DIVA)#
# (Ronquist 1997)#
############################################################
results_object = results_list_save[[3]]#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith DIVA 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
##############################################################
# 3-parameter model (LAGRANGE DEC + founder-event speciation)#
# See Matzke 2013 (poster, in press)#
##############################################################
results_object = results_list_save[[4]]#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips, adj=1.1)# pos=2, offset=1)#
title("ML marginal ancestral ranges at branch tops with\nBioGeoBEARS 3-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
if (doPDFs)#
	{#
	dev.off()#
	}#
#
system(paste("open ", pdffn, sep=""))
bears_output
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit
Let's try joint splits/states#
########################################################
#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit
numstates
tipranges
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2
numstates_from_numareas
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
dim(joint_splitprobs_at_internal_nodes)
bears_output
?cladoRcpp
ca = c(1,2,3,4,5)#
cb = c(2,2,2,2,2)#
rcpp_convolve(a=ca, b=cb)#
#'#
# Same as:#
convolve(ca, cb, conj=TRUE, type="open")
ca = c(1,2,3,4,5)#
cb = c(2,2,2,2,2)#
rcpp_mult2probvect(a=ca, b=cb)#
#
# Same as:#
c(ca %o% cb)#
#
# Or:#
outer(ca, cb)#
c(outer(ca, cb))#
#
# Or:#
tcrossprod(ca, cb)#
c(tcrossprod(ca, cb))
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
dim(joint_splitprobs_at_internal_nodes)
i
Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]
rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)
sum(rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob))
max(rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob))
ancnodes_left_daughter_downpass_relprob
ancnodes_right_daughter_downpass_relprob
bears_output
bears_output
?cladoRcpp
spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s_param = spPmat_inputs$maxent01s_param#
	maxent01v_param = spPmat_inputs$maxent01v_param#
	maxent01j_param = spPmat_inputs$maxent01j_param#
	maxent01y_param = spPmat_inputs$maxent01y_param#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs,#
		Rcpp_rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=damt, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)
COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs,#
		Rcpp_rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)
We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs,#
		Rcpp_rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)
leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)
COO_weights_columnar
sum(COO_weights_columnar[[4]])
rcpp_calc_anclikes_sp_COOweights_faster
leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar
leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar
COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
    COO_weights_columnar_rowsums
COO_weights_columnar
We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums)#
    stateprobs
We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs
leftprobs
rightprobs
COO_weights_columnar
We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
	COO_weights_columnar = NULL
COO_weights_columnar
COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)
COO_weights_columnar_rowsums
stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs
leftprobs
rightprobs
stateprobs
sum(stateprobs,na.rm=TRUE)
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes * joint_uppass_likelihoods_of_splits_just_above_nodes#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above * joint_uppass_likelihoods_of_states_dependent_on_splits_above#
	joint_marginal_states_dependent_on_splits_above = tmp#
	}
dim(joint_downpass_likelihoods_of_splits_just_above_nodes)
anc
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes * joint_uppass_likelihoods_of_splits_just_above_nodes#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above * joint_uppass_likelihoods_of_states_dependent_on_splits_above#
	joint_marginal_states_dependent_on_splits_above = tmp#
	}
dim(joint_downpass_likelihoods_of_splits_just_above_nodes)
anc
length(tmp)
numstates
15^2
16^2
bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]
bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,]
Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes * joint_uppass_likelihoods_of_splits_just_above_nodes#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above * joint_uppass_likelihoods_of_states_dependent_on_splits_above#
	joint_marginal_states_dependent_on_splits_above = tmp#
	}
length(joint_marginal_splitprobs_at_internal_nodes[anc, ])
length(tmp)
dim(tmp)
dim(joint_marginal_splitprobs_at_internal_nodes)
dim(tmp)
dim(joint_downpass_likelihoods_of_splits_just_above_nodes)
dim(joint_uppass_likelihoods_of_splits_just_above_nodes)
?"%*%"
joint_downpass_likelihoods_of_splits_just_above_nodes
joint_uppass_likelihoods_of_splits_just_above_nodes
i
Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)
COO_weights_columnar
COO_weights_columnar_rowsums
Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs
stateprobs
tmp
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	joint_marginal_states_dependent_on_splits_above = tmp#
	}
joint_marginal_states_dependent_on_splits_above
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}
joint_marginal_states_dependent_on_splits_above
rowSums(joint_marginal_states_dependent_on_splits_above)
dim(joint_marginal_splitprobs_at_internal_nodes)
rowSums(joint_marginal_splitprobs_at_internal_nodes)
rowSums(joint_uppass_likelihoods_of_splits_just_above_nodes)
Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}
joint_marginal_states_dependent_on_splits_above
rowSums(joint_marginal_states_dependent_on_splits_above)
Compare to states from BioGeoBEARS 2-parameter analysis#
########################################################
bears_output = bears_2param_standard_fast(trfn=trfn, geogfn=geogfn)#
bears_output
Extract key parameters and LnL values#
fn_name = "bears_2param_standard_fast"#
tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
results_row = cbind(fn_name, t(tmp_params), tmp_LnL)#
results_row#
########################################################
# Make plots#
########################################################
#
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
########################################################
########################################################
# Plot the various ancestral state estimates#
########################################################
########################################################
piecols = c("black", #
rgb(blue=100, green=0, red=0, maxColorValue=100), #
rgb(blue=100, green=100, red=0, maxColorValue=100), #
rgb(blue=0, green=100, red=100, maxColorValue=100), #
rgb(blue=0, green=0, red=100, maxColorValue=100), #
#
rgb(blue=100, green=50, red=0, maxColorValue=100), #
rgb(blue=75, green=50, red=50, maxColorValue=100), #
rgb(blue=75, green=0, red=50, maxColorValue=100), #
#
rgb(blue=0, green=100, red=50, maxColorValue=100), #
rgb(blue=0, green=50, red=50, maxColorValue=100), #
#
rgb(blue=0, green=50, red=100, maxColorValue=100), #
rgb(blue=50, green=25, red=25, maxColorValue=100), #
rgb(blue=50, green=50, red=25, maxColorValue=100), #
rgb(blue=25, green=25, red=50, maxColorValue=100), #
#
rgb(blue=25, green=50, red=50, maxColorValue=100), #
#
rgb(blue=100, green=100, red=100, maxColorValue=100))#
doPDFs = FALSE#
pdffn = "compare_anc_range_reconstructions_v01.pdf"#
if (doPDFs) #
	{#
	pdf(pdffn, height=11, width=8)#
	}#
par(mfrow=c(2,1))#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on downpass cond. likes. at branch tops with\nLAGRANGE 2-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Extract key parameters and LnL values#
fn_name = "bears_2param_standard_fast"#
tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
results_row = cbind(fn_name, t(tmp_params), tmp_LnL)#
results_row#
########################################################
# Make plots#
########################################################
#
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
########################################################
########################################################
# Plot the various ancestral state estimates#
########################################################
########################################################
piecols = c("black", #
rgb(blue=100, green=0, red=0, maxColorValue=100), #
rgb(blue=100, green=100, red=0, maxColorValue=100), #
rgb(blue=0, green=100, red=100, maxColorValue=100), #
rgb(blue=0, green=0, red=100, maxColorValue=100), #
#
rgb(blue=100, green=50, red=0, maxColorValue=100), #
rgb(blue=75, green=50, red=50, maxColorValue=100), #
rgb(blue=75, green=0, red=50, maxColorValue=100), #
#
rgb(blue=0, green=100, red=50, maxColorValue=100), #
rgb(blue=0, green=50, red=50, maxColorValue=100), #
#
rgb(blue=0, green=50, red=100, maxColorValue=100), #
rgb(blue=50, green=25, red=25, maxColorValue=100), #
rgb(blue=50, green=50, red=25, maxColorValue=100), #
rgb(blue=25, green=25, red=50, maxColorValue=100), #
#
rgb(blue=25, green=50, red=50, maxColorValue=100), #
#
rgb(blue=100, green=100, red=100, maxColorValue=100))#
doPDFs = FALSE#
pdffn = "compare_anc_range_reconstructions_v01.pdf"#
if (doPDFs) #
	{#
	pdf(pdffn, height=11, width=8)#
	}#
par(mfrow=c(2,1))#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on downpass cond. likes. at branch tops with\nLAGRANGE 2-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
########################################################
# Plot LAGRANGE C++ again#
########################################################
map_LG_MLstates_to_tree(MLstates_LGcpp, tr, tiprange_names, removechar="_", type="C++")
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0, stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0, stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = c(0, tmp)#
	}#
############################################################
# Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0, stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0, stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = c(0, tmp)#
	}#
############################################################
# Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
i
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)
Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)
COO_weights_columnar
COO_weights_columnar_rowsums
s
v
j
y
Rcpp_leftprobs
leftprobs
add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]
ancnodes_left_daughter_downpass_relprob
Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0, stateprobs)
dim(joint_downpass_likelihoods_of_states_dependent_on_splits_above)
length(stateprobs)
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = stateprobs#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}
joint_marginal_states_dependent_on_splits_above
stateprobs
length(stateprobs)
leftprobs
stateprobs
length(stateprobs)
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}
joint_marginal_states_dependent_on_splits_above
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
rowSums(joint_marginal_states_dependent_on_splits_above)
rowSums(joint_marginal_states_dependent_on_splits_above)
joint_marginal_states_dependent_on_splits_above
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt
v
j
bears_output
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes
MLstates_txt_tips
MLstates_txt_tips
MLstates_txt_nodes
results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
#MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_tips#
#MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes = MLstateMLstates_txts_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
#MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_tips#
#MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes = MLstates_txt#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
MLstates_txt_tips
length(MLstates_txt_tips)
MLstates_txt
length(MLstates_txt)
ntips = length(tr$tip.label)#
#MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_tips#
#MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes = MLstates_txt#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")
length(tr$tip.label)
MLstates_txt_tips
MLstates_txt_nodes
length(MLstates_txt_tips)
results_object = bears_output#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]
MLstates_txt_tips
bears_output
Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}#
#
# Add the tip likelihoods, from e.g. the standard downpass likelihoods#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_downpass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_uppass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_marginal_states_dependent_on_splits_above = rbind(bears_output$ML_marginal_prob_each_state_at_branch_top_AT_node, joint_marginal_states_dependent_on_splits_above)
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
#MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_tips = #
#MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes = MLstates_txt#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
Source code#
########################################################
library(LaplacesDemon)#
library(BioGeoBEARS)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_basics_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_generics_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_classes_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_univ_model_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_readwrite_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_LaplacesDemon_v1.R', chdir = TRUE)#
#source('/Dropbox/_njm/_biogeog_sim_utils_v1.R', chdir = TRUE)#
########################################################
# File locations#
########################################################
# In package#
extdata_dir = system.file("extdata", package="BioGeoBEARS")#
# development#
extdata_dir = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/"#
########################################################
# Input files (tree and tipdata)#
########################################################
trfn = paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep="")#
tr = read.tree(trfn)#
geogfn = paste(addslash(extdata_dir), "Psychotria_geog.data", sep="")#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges = order_tipranges_by_tree_tips(tipranges, tr)#
tiprange_names = tipranges_to_area_strings(tipranges=tipranges)#
tiprange_names#
#
########################################################
# Reading Python LAGRANGE results#
########################################################
wd = slashslash(paste(extdata_dir, "/examples/Psychotria_M0/LAGRANGE_python/", sep=""))#
setwd(wd)#
outfn = "Psychotria_5.2_demo.results.txt"#
results_dir = wd#
new_splits_fn = TRUE#
new_states_fn = FALSE#
filecount=0#
#
summstats = parse_lagrange_python_output(outfn, results_dir, new_splits_fn = TRUE, new_states_fn = FALSE, filecount=0)#
summstats#
########################################################
# OK now read the Python LAGRANGE version#
########################################################
splits_fn = "Psychotria_5.2_demo.results_splits00001.txt"#
moref(splits_fn)#
#
splits_LGpy = LGpy_splits_fn_to_table(splits_fn)#
MLsplits_LGpy = LGpy_MLsplit_per_node(splits_LGpy)#
#MLsplits_LGpy = map_LGpy_MLsplits_to_tree(MLsplits_LGpy, tr, tiprange_names)#
MLsplits_LGpy = map_LG_MLsplits_to_tree(MLsplits_LGpy, tr, tiprange_names, type="python")#
########################################################
# OK now read the C++ LAGRANGE version#
########################################################
# wd = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_python/"#
# setwd(wd)#
outfn = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/Psychotria_M0_lgcpp_out.txt"#
results_dir = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/"#
new_splits_fn = TRUE#
new_states_fn = TRUE#
filecount=0#
#
summstats = parse_lagrange_output(outfn, results_dir, new_splits_fn, new_states_fn, filecount)#
summstats#
#
splits_fn = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/Psychotria_M0_lgcpp_out_splits00001.txt"#
#
splits_LGcpp = LGcpp_splits_fn_to_table(splits_fn)#
MLsplits_LGcpp = LGpy_MLsplit_per_node(splits_LGcpp)#
MLsplits_LGcpp = map_LG_MLsplits_to_tree(MLsplits_LGcpp, tr, tiprange_names, removechar="_", type="C++")#
MLsplits_LGcpp#
########################################################
# Put the splits on the corners#
########################################################
sourcedir = '/Dropbox/_njm/'#
source3 = '_R_tree_functions_v1.R'#
source(paste(sourcedir, source3, sep=""))#
#
# Get corner coordinates#
corners_list = corner_coords(tr)#
leftcorns = corners_list$leftcorns#
rightcorns = corners_list$rightcorns#
#
# Plot splits on corners#
# Ensure correct order#
MLsplits_LGcpp = order_LGnodes(MLsplits_LGcpp, removechar="_", type="C++")#
MLsplits_LGcpp#
#
plot(tr, label.offset=0.15)#
cornerlabels(text=MLsplits_LGcpp$leftBB, coords=leftcorns, bg="green3")#
cornerlabels(text=MLsplits_LGcpp$rightBB, coords=rightcorns, bg="green3")#
tiplabels(tiprange_names)#
axisPhylo()#
mtext(text="million years ago", side=1, line=2)#
########################################################
# Get the states from LAGRANGE C++#
########################################################
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_readwrite_v1.R', chdir = TRUE)#
#
# wd = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_python/"#
# setwd(wd)#
outfn = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/Psychotria_M0_lgcpp_out.txt"#
results_dir = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/"#
new_splits_fn = TRUE#
new_states_fn = TRUE#
filecount=0#
#
summstats = parse_lagrange_output(outfn, results_dir, new_splits_fn, new_states_fn, filecount)#
summstats#
#
states_fn = "/Dropbox/_njm/__packages/BioGeoBEARS_setup/inst/extdata/examples/Psychotria_M0/LAGRANGE_C++/Psychotria_M0_lgcpp_out_states00001.txt"#
#
states_LGcpp = LGcpp_states_fn_to_table(states_fn)#
MLstates_LGcpp = LGcpp_MLstate_per_node(states_LGcpp)#
order_LGnodes(MLstates_LGcpp, removechar=NULL, type="C++", type2="states")#
MLstates_LGcpp = map_LG_MLstates_to_tree(MLstates_LGcpp, tr, tiprange_names, removechar="_", type="C++")#
MLstates_LGcpp#
########################################################
# Compare to states from BioGeoBEARS 2-parameter analysis#
########################################################
bears_output = bears_2param_standard_fast(trfn=trfn, geogfn=geogfn)#
bears_output#
# Extract key parameters and LnL values#
fn_name = "bears_2param_standard_fast"#
tmp_params = get_infparams_optimx_nosim(bears_output, fn_name)#
tmp_LnL = get_inf_LgL_etc_optimx(bears_output)#
results_row = cbind(fn_name, t(tmp_params), tmp_LnL)#
results_row#
########################################################
# Make plots#
########################################################
#
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
########################################################
########################################################
# Plot the various ancestral state estimates#
########################################################
########################################################
piecols = c("black", #
rgb(blue=100, green=0, red=0, maxColorValue=100), #
rgb(blue=100, green=100, red=0, maxColorValue=100), #
rgb(blue=0, green=100, red=100, maxColorValue=100), #
rgb(blue=0, green=0, red=100, maxColorValue=100), #
#
rgb(blue=100, green=50, red=0, maxColorValue=100), #
rgb(blue=75, green=50, red=50, maxColorValue=100), #
rgb(blue=75, green=0, red=50, maxColorValue=100), #
#
rgb(blue=0, green=100, red=50, maxColorValue=100), #
rgb(blue=0, green=50, red=50, maxColorValue=100), #
#
rgb(blue=0, green=50, red=100, maxColorValue=100), #
rgb(blue=50, green=25, red=25, maxColorValue=100), #
rgb(blue=50, green=50, red=25, maxColorValue=100), #
rgb(blue=25, green=25, red=50, maxColorValue=100), #
#
rgb(blue=25, green=50, red=50, maxColorValue=100), #
#
rgb(blue=100, green=100, red=100, maxColorValue=100))#
doPDFs = FALSE#
pdffn = "compare_anc_range_reconstructions_v01.pdf"#
if (doPDFs) #
	{#
	pdf(pdffn, height=11, width=8)#
	}#
par(mfrow=c(2,1))#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on downpass cond. likes. at branch tops with\nLAGRANGE 2-parameter model (not real inference)")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
############################################################
# 2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
########################################################
# Plot LAGRANGE C++ again#
########################################################
map_LG_MLstates_to_tree(MLstates_LGcpp, tr, tiprange_names, removechar="_", type="C++")#
# Compare probs:#
MLstates_LGcpp_justMLprob = MLstates_LGcpp$relprob[order(MLstates_LGcpp$Rnodes)]#
#
nums = length(tr$tip.label)+1 : tr$Nnode#
MLstates_bears = probs[nums,1]#
#
plot(MLstates_LGcpp_justMLprob, MLstates_bears, xlim=c(0,1), ylim=c(0,1))#
########################################################
# Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}#
#
# Add the tip likelihoods, from e.g. the standard downpass likelihoods#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_downpass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_uppass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_marginal_states_dependent_on_splits_above = rbind(bears_output$ML_marginal_prob_each_state_at_branch_top_AT_node, joint_marginal_states_dependent_on_splits_above)#
############################################################
# Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])
MLstates_probs
2-parameter model (as in LAGRANGE)#
# (Ree & Smith 2008)#
############################################################
results_object = bears_output#
relprobs_matrix = results_object$ML_marginal_prob_each_state_at_branch_top_AT_node#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("ML marginal ancestral ranges at branch tops\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=results_object$ML_marginal_prob_each_state_at_branch_top_AT_node)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
########################################################
# Plot LAGRANGE C++ again#
########################################################
map_LG_MLstates_to_tree(MLstates_LGcpp, tr, tiprange_names, removechar="_", type="C++")#
# Compare probs:#
MLstates_LGcpp_justMLprob = MLstates_LGcpp$relprob[order(MLstates_LGcpp$Rnodes)]#
nums = length(tr$tip.label)+1 : tr$Nnode#
MLstates_bears_2param = probs[nums,1]#
#
#plot(MLstates_LGcpp_justMLprob, MLstates_bears, xlim=c(0,1), ylim=c(0,1))#
########################################################
# Let's try joint splits/states#
########################################################
# Get ranges from geogfn#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Get the default areas#
areas = getareas_from_tipranges_object(tipranges)#
areas#
#
# Name the areas (Kauai, Oahu, Maui-Nui, Hawaii)#
areas = c("K","O","M","H")#
#
# Make states and state indices#
states = areas_list_to_states_list_old(areas=areas)#
states#
states2 = rcpp_areas_list_to_states_list(areas=areas)#
states2#
# Go down tree and get the downpass marginal probs above#
# each node; then multiply to get the downpass marginal#
# splits at each node#
phy = tr#
#
phy2 <- reorder(phy, "pruningwise")#
numtips = length(phy2$tip.label)#
tipnums <- 1:numtips#
num_internal_nodes = phy2$Nnode#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
edges_to_visit#
#
# Numstates during cladogenesis does NOT include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
joint_uppass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_downpass_likelihoods_of_splits_just_above_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
joint_marginal_splitprobs_at_internal_nodes = matrix(NA, nrow=num_internal_nodes, ncol=numstates*numstates)#
#
# We can also do the ancstates, DEPENDENT on the splits#
# Numstates during anagenesis DOES include the null range#
numstates = numstates_from_numareas(numareas=length(areas), include_null_range=TRUE)#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
joint_marginal_states_dependent_on_splits_above = matrix(NA, nrow=num_internal_nodes, ncol=numstates)#
#
dim(joint_splitprobs_at_internal_nodes)#
########################################################
########################################################
# THIS IS A DOWNPASS FROM THE TIPS TO THE ROOT#
########################################################
########################################################
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
	#print(j)#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- phy2$edge[i, 2]#
	right_desc_nodenum <- phy2$edge[j, 2]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- phy2$edge[i, 1]#
	# Here, we are just doing internal nodes, so#
	anc = anc - numtips#
#
	# Get the cladogenesis COO matrix#
	# We can also do the ancstates, DEPENDENT on the splits#
	# Using COOmat#
	spPmat_inputs = bears_output$spPmat_inputs#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	dmat = spPmat_inputs$dmat#
	maxent01s = spPmat_inputs$maxent01s_param#
	maxent01v = spPmat_inputs$maxent01v_param#
	maxent01j = spPmat_inputs$maxent01j_param#
	maxent01y = spPmat_inputs$maxent01y_param#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	numstates = numstates_from_numareas(numareas=length(areas), include_null_range=FALSE)#
	leftprobs = rep(1, numstates)#
	rightprobs = rep(1, numstates)#
	COO_weights_columnar = NULL#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=leftprobs,#
		Rcpp_rightprobs=rightprobs, l=l, s=s, v=v, j=j, y=y,#
		dmat=dmat, maxent01s=maxent01s, maxent01v=maxent01v,#
		maxent01j=maxent01j, maxent01y=maxent01y,#
		max_minsize_as_function_of_ancsize = NULL,#
		printmat = TRUE)#
	COO_weights_columnar#
	COO_weights_columnar_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,#
    numstates)#
	# Get the relative probabilities (scaled conditional downpass likelihoods)#
	# of each state on the downpass#
	# add [-1] to not use null range in cladogenesis model#
	ancnodes_left_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_downpass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_downpass_relprob, b=ancnodes_right_daughter_downpass_relprob)#
	# This does sum to 1#
	joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_downpass_relprob#
	rightprobs = ancnodes_right_daughter_downpass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# Also gather the uppass likelihoods the same way#
	ancnodes_left_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[left_desc_nodenum,][-1]#
	ancnodes_right_daughter_uppass_relprob = bears_output$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[right_desc_nodenum,][-1]#
#
	# Do a fast cross-product with cladoRcpp:::rcpp_mult2probvect(a=ca, b=cb)#
	require(cladoRcpp)#
	tmp = rcpp_mult2probvect(a=ancnodes_left_daughter_uppass_relprob, b=ancnodes_right_daughter_uppass_relprob)#
	# This does sum to 1#
	joint_uppass_likelihoods_of_splits_just_above_nodes[anc,] = tmp#
	# Same either way for rowsums (just placeholders), but we need real probs #
	# for rcpp_calc_splitlikes_using_COOweights_columnar#
	leftprobs = ancnodes_left_daughter_uppass_relprob#
	rightprobs = ancnodes_right_daughter_uppass_relprob#
#
    stateprobs = rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs=leftprobs,#
    Rcpp_rightprobs=rightprobs, COO_weights_columnar, Rsp_rowsums=COO_weights_columnar_rowsums)#
    stateprobs[is.nan(stateprobs)] = 0.0#
    # Normalize & store#
    stateprobs = stateprobs / sum(stateprobs, na.rm=TRUE)#
    joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc, ] = c(0,stateprobs)#
	# And, the marginal is just the uppass * the downpass#
	tmp = joint_downpass_likelihoods_of_splits_just_above_nodes[anc,] * joint_uppass_likelihoods_of_splits_just_above_nodes[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_splitprobs_at_internal_nodes[anc,] = tmp#
	# For states also#
	tmp = joint_downpass_likelihoods_of_states_dependent_on_splits_above[anc,] * joint_uppass_likelihoods_of_states_dependent_on_splits_above[anc,]#
	tmp = tmp / sum(tmp, na.rm=TRUE)#
	joint_marginal_states_dependent_on_splits_above[anc,] = tmp#
	}#
#
# Add the tip likelihoods, from e.g. the standard downpass likelihoods#
joint_downpass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_downpass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_uppass_likelihoods_of_states_dependent_on_splits_above = rbind(bears_output$condlikes_of_each_state, joint_uppass_likelihoods_of_states_dependent_on_splits_above)#
#
joint_marginal_states_dependent_on_splits_above = rbind(bears_output$ML_marginal_prob_each_state_at_branch_top_AT_node, joint_marginal_states_dependent_on_splits_above)#
############################################################
# Plot splitprob-based states#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_marginal_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
# Compare probs (C++ Lagrange states, and BEARS 2-param marginal states)#
plot(MLstates_LGcpp_justMLprob, MLstates_bears_2param, xlim=c(0,1), ylim=c(0,1))#
# Compare probs:#
#MLstates_LGcpp_justMLprob = MLstates_LGcpp$relprob[order(MLstates_LGcpp$Rnodes)]#
nums = length(tr$tip.label)+1 : tr$Nnode#
MLstates_bears_2param_states_dependent_on_joint_splits = MLstates_probs[nums,1]#
plot(MLstates_LGcpp_justMLprob, MLstates_bears_2param_states_dependent_on_joint_splits, xlim=c(0,1), ylim=c(0,1))
MLstates_probs
MLstates_LGcpp_justMLprob = MLstates_LGcpp$relprob[order(MLstates_LGcpp$Rnodes)]#
nums = length(tr$tip.label)+1 : tr$Nnode#
MLstates_bears_2param_states_dependent_on_joint_splits = probs[nums,1]#
plot(MLstates_LGcpp_justMLprob, MLstates_bears_2param_states_dependent_on_joint_splits, xlim=c(0,1), ylim=c(0,1))
probs
Plot splitprob-based states (downpass likelihoods)#
############################################################
#results_object = bears_output#
relprobs_matrix = joint_downpass_likelihoods_of_states_dependent_on_splits_above#
MLstates_0based_indexes = get_ML_states(relprobs_matrix)#
#
MLstates = list()#
for (i in 1:length(MLstates_0based_indexes))#
	{#
	MLstates[[i]] = states[[ MLstates_0based_indexes[[i]]+1 ]]#
	}#
#
MLstates#
#
MLstates_txt = unlist(lapply(X=MLstates, FUN=paste, sep="", collapse=""))#
MLstates_txt#
#
ntips = length(tr$tip.label)#
MLstates_txt_tips = MLstates_txt[1:ntips]#
MLstates_txt_nodes = MLstates_txt[(1+ntips):(length(MLstates_txt))]#
MLstates_txt_nodes#
#
tr2 = reorder(tr, "pruningwise")#
plot(tr2, label.offset=0.15)#
nodelabels(MLstates_txt_nodes)#
tiplabels(MLstates_txt_tips)#
title("Best states based on marginal joint splitprobs above node\nwith LAGRANGE 2-parameter model")#
#
# Pie charts#
MLstates_probs = get_ML_probs(relprobs_matrix=relprobs_matrix)#
MLstates_probs = unlist(MLstates_probs)#
MLstates_probs_other = 1-MLstates_probs#
probs = cbind(MLstates_probs, MLstates_probs_other)#
#
plot(tr2, label.offset=0.15)#
#tiplabels(pie=relprobs_matrix[1:ntips,], piecol=piecols)#
#nodelabels(pie=relprobs_matrix[(1+ntips):(length(MLstates_txt)),], piecol=piecols)#
tiplabels(pie=probs[1:ntips,])#
nodelabels(pie=probs[(1+ntips):(length(MLstates_txt)),])#
# Compare probs (C++ Lagrange states, and BEARS 2-param marginal states)#
plot(MLstates_LGcpp_justMLprob, MLstates_bears_2param, xlim=c(0,1), ylim=c(0,1))#
# Compare probs:#
#MLstates_LGcpp_justMLprob = MLstates_LGcpp$relprob[order(MLstates_LGcpp$Rnodes)]#
nums = length(tr$tip.label)+1 : tr$Nnode#
MLstates_bears_2param_states_dependent_on_joint_splits = probs[nums,1]#
plot(MLstates_LGcpp_justMLprob, MLstates_bears_2param_states_dependent_on_joint_splits, xlim=c(0,1), ylim=c(0,1))
x=1
if (x==NULL)
))
x==NULL
x==NA
add_to_downpass(tr)
add_to_downpass_labels
add_to_downpass_labels(tr)
add_to_downpass_labels(tr, currnode=1)
get_lagrange_nodenums(tr)
numstates
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
LnL = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
LnL
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
#
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
LnL = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
LnL
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
#
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
LnL = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
LnL
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
#
# Works!#
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
optim_result#
#
# Fix all states at the nodes#
# assumes numstates is WITHOUT null range#
optim_results = NULL#
for (i in 1:numstates)#
	{#
	stateindex_0based_with_NULL_range = i#
	statenum = stateindex_0based_with_NULL_range#
	fixnode = 20#
	fixlikes = rep(0, numstates)#
	fixlikes[i] = 1#
	optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
	optim_result = c(fixnode, statenum, optim_result)#
	optim_results = rbind(optim_results, optim_result)#
	}#
optim_results
optim_result
unlist(optim_result)
c(optim_result)
unlist(optim_result)
as.numeric()
as.numeric(unlist(optim_result))
names(optim_result)
None of these really line up.  Let's try optimization, conditional on a fixed state at a node.#
#
# Fix the ancestral node (node 20) to state 5 (K_O), to see if we can get what#
# LAGRANGE C++ gives us for this state:#
# 18	K_O	0.516739	35.2022#
# 18	K	0.278394	35.8207#
# 18	K_O_M	0.0730309	37.1588#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
#
# Works!#
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
optim_result#
#
# Fix all states at the nodes#
# assumes numstates is WITHOUT null range#
optim_results = NULL#
for (i in 1:numstates)#
	{#
	stateindex_0based_with_NULL_range = i#
	statenum = stateindex_0based_with_NULL_range#
	fixnode = 20#
	fixlikes = rep(0, numstates)#
	fixlikes[i] = 1#
	optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
	optim_result2 = c(fixnode, statenum, optim_result)#
	optim_results = rbind(optim_results, unlist(optim_result))#
	}#
#
optim_results = as.data.frame(optim_results)#
names(optim_results) = c("fixnode", "statenum", "d", "e", "LnL", "method", "fns", "grs", "itns", "conv", "KKT1", "KKT2", "xtimes")#
optim_results = dfnums_to_numeric(optim_results)#
optim_results
optim_results = NULL#
#for (i in 1:numstates)#
for (i in 1:2)#
	{#
	stateindex_0based_with_NULL_range = i#
	statenum = stateindex_0based_with_NULL_range#
	fixnode = 20#
	fixlikes = rep(0, numstates)#
	fixlikes[i] = 1#
	optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
	optim_result2 = c(fixnode, statenum, unlist(optim_result))#
	optim_results = rbind(optim_results, optim_result2)#
	}#
#
optim_results = as.data.frame(optim_results)#
names(optim_results) = c("fixnode", "statenum", "d", "e", "LnL", "method", "fns", "grs", "itns", "conv", "KKT1", "KKT2", "xtimes")#
optim_results = dfnums_to_numeric(optim_results)#
optim_results
optim_results
adf3
adf2
adf4
adf2(optim_results)
optim_results = adf2(optim_results)#
names(optim_results) = c("fixnode", "statenum", "d", "e", "LnL", "method", "fns", "grs", "itns", "conv", "KKT1", "KKT2", "xtimes")
get_lagrange_nodenums(tr)
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_models_v1.R', chdir = TRUE)#
source('/Dropbox/_njm/__packages/BioGeoBEARS_setup/calc_loglike_sp_v01.R', chdir = TRUE)#
#
# Works!#
fixnode = 20#
fixlikes = rep(0, numstates)#
fixlikes[5] = 1#
optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
optim_result#
#
# Fix all states at the nodes#
# assumes numstates is WITHOUT null range#
optim_results = NULL#
for (nodenum in nums)#
	{#
	for (i in 1:numstates)#
	#for (i in 1:2)#
		{#
		stateindex_0based_with_NULL_range = i#
		statenum = stateindex_0based_with_NULL_range#
		fixnode = nodenum#
		fixlikes = rep(0, numstates)#
		fixlikes[i] = 1#
		optim_result = bears_2param_standard_fast_fixnode(trfn=trfn, geogfn=geogfn, fixnode=fixnode, fixlikes=fixlikes)#
		optim_result2 = c(fixnode, statenum, unlist(optim_result))#
		optim_results = rbind(optim_results, optim_result2)#
		}#
	}#
#
optim_results = adf2(optim_results)#
names(optim_results) = c("fixnode", "statenum", "d", "e", "LnL", "method", "fns", "grs", "conv", "KKT1", "KKT2", "xtimes")#
optim_results = dfnums_to_numeric(optim_results)#
optim_results#
#
# Lagrange node 18#
optim_results[optim_results$fixnode==20, ]#
#
# Lagrange node 1#
optim_results[optim_results$fixnode==27, ]#
#
# Lagrange node 11#
optim_results[optim_results$fixnode==32, ]
optim_results
nn = 18#
ns = 15#
nn * ns
dim(optim_results)
save(optim_results, "/Dropbox/_njm/__packages/BioGeoBEARS_setup/_examples/Psychotria_2param_MLstates_local.Rdata")
save(optim_results, file="/Dropbox/_njm/__packages/BioGeoBEARS_setup/_examples/Psychotria_2param_MLstates_local.Rdata")
bears_2param_standard_fast_result = bears_2param_standard_fast(trfn=trfn, geogfn=geogfn)#
bears_2param_standard_fast_result = bears_2param_standard_fast_result$optim_result
bears_2param_standard_fast_result
optim_results
global_ML_LnL = bears_2param_standard_fast_result$fvalues#
relprobs_under_local_ML = exp(optim_results$LnL) / exp(global_ML_LnL)#
relprob = relprobs_under_local_ML#
#
colnums = (1:ncol(optim_results))#
LnLcol = colnums[names(optim_results) == "LnL"]#
optim_results2 = cbind(optim_results[, 1:LnLcol], relprob, optim_results[, (LnLcol+1):ncol(optim_results)])
optim_results$LnL
class(optim_results$LnL)
global_ML_LnL
bears_2param_standard_fast_result$fvalues
bears_2param_standard_fast_result$fvalues[[1]]
adf4
optim_results
unlist_df4(optim_results)
global_ML_LnL = bears_2param_standard_fast_result$fvalues[[1]]#
relprobs_under_local_ML = exp(optim_results$LnL) / exp(global_ML_LnL)#
relprob = relprobs_under_local_ML
relprob
colnums = (1:ncol(optim_results))#
LnLcol = colnums[names(optim_results) == "LnL"]#
optim_results2 = cbind(optim_results[, 1:LnLcol], relprob, optim_results[, (LnLcol+1):ncol(optim_results)])
optim_results2
optim_results2[optim_results2$fixnode==20, ]#
#
# Lagrange node 1#
optim_results2[optim_results2$fixnode==27, ]#
#
# Lagrange node 11#
optim_results2[optim_results2$fixnode==32, ]
Lagrange node 18#
subtable = optim_results2[optim_results2$fixnode==20, ]#
subtable[order(subtable$relprob), ]#
#
# Lagrange node 1#
subtable = optim_results2[optim_results2$fixnode==27, ]#
subtable[order(subtable$relprob), ]#
#
# Lagrange node 11#
subtable = optim_results2[optim_results2$fixnode==32, ]#
subtable[order(subtable$relprob), ]
Lagrange node 18#
subtable = optim_results2[optim_results2$fixnode==20, ]#
subtable[rev(order(subtable$relprob)), ]#
#
# Lagrange node 1#
subtable = optim_results2[optim_results2$fixnode==27, ]#
subtable[rev(order(subtable$relprob)), ]#
#
# Lagrange node 11#
subtable = optim_results2[optim_results2$fixnode==32, ]#
subtable[rev(order(subtable$relprob)), ]
get_lagrange_nodenums(tr)
